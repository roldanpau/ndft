/** \file diffusion_shortest_path_TM.c
  * \brief Starting at the given IC, successively iterate the IM and TM1,TM2 to gain action.
  *
  * We use a shortest path algorithm to produce the diffusion pseudo-orbit:
  * The domain [0,pi] x [0,7] is subdivided in nCellsPhi x nCellsI `cells'
  * (rectangles).
  * Iterate the map (IM, TM1, TM2) dictated by the shortest path from the
  * current cell to the target cell, as found by Dijkstra's algorithm.
  *
  * NOTES: 
  *		Fourier-Taylor coeffs for the generating function are read from files
  *		ddA.res and ddB.res, which were generated by FT. 
  *
  *		Taylor coeffs for omega are read from ddOmega.res, which was generated
  *		by T.
  *
  * USAGE:	./diffusion_shortest_path I_src phi_src I_target, phi_target, for example 
  *			./diffusion_shortest_path 1 3.14 7 0
  *
  * CALLED BY: diffusion_shortest_path_TM.sh
  *
  */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>       // fabs
#include <assert.h>
#include "FT_module.h"
#include "T_module.h"
#include "TM_module.h"
#include "SM_module.h"
#include "IM_module.h"
#include "dijkstra_module.h"

static const char ddOmega_FILE[] = "ddOmega.res";
static const char ddOmega_FILE_SM2[] = "ddOmega_SM2.res";

const int nfour=65; 	/* Number of Fourier coeffs used in FFT */
const int ntori=8;		/* Number of tori used in numerical SM */

const int N = 4;    /* Degree of Fourier series */
const int M = 6;    /* Degree of Taylor series */

const int nCellsI = 30;		/* Number of cells in the I direction */
const int nCellsPhi = 30;	/* Number of cells in the phi direction */
const int nCells = nCellsI*nCellsPhi;	/* Total number of cells (vertices) */

const double dI = 7.0/nCellsI;
const double dphi = M_PI/nCellsPhi;

void cell2pt(int i, int j, double *I, double *phi)
{
	assert(i>= 0 && i<nCellsI);
	assert(j>= 0 && j<nCellsPhi);

	*I = i*dI + dI/2;
	*phi = j*dphi + dphi/2;
}

void pt2cell(double I, double phi, int *i, int *j)
{
	assert(I>= 0);
	assert(phi>= 0 && phi<=M_PI);

	if(I<7) 
	{
		*i = (int) (I/dI);
	}
	else
	{
		/* Cell is outside domain. Identify it with closest cell */
		*i = nCellsI-1;
	}
	*j = (int) (phi/dphi);
}

void initGraph(double ddA[nfour][ntori], double ddB[nfour][ntori], 
		double ddOmega[ntori-1], 
		double ddA_SM2[nfour][ntori], double ddB_SM2[nfour][ntori],
		double ddOmega_SM2[ntori-1], 
		int graph[MAX_VERTICES][MAX_VERTICES], 
		int graphMaps[MAX_VERTICES][MAX_VERTICES]) 
{
	int i,j;
	int ip,jp;
	double phi,I;

    double Ip, phip;    /* (I', \phi') = Image of (I, phi) by the IM/TM1/TM2 */

	/* Initialize graph to all zeros, and graphMaps to all -1 */
	for(i=0; i<nCells; i++)
	{
		for(j=0; j<nCells; j++)
		{
			graph[i][j] = 0;
			graphMaps[i][j] = -1;
		}
	}

	/* Add (directed) edges corresponding to TM1, and assign them a distance of
	 * 6 time units. */
	for(i=0; i<nCellsI; i++)
	{
		for(j=0; j<nCellsPhi; j++)
		{
			cell2pt(i,j,&I,&phi);

			/* Compute TM1 */
			TM(nfour, ntori, ddA, ddB, ddOmega, N, M, I, phi, &Ip, &phip);
			pt2cell(Ip,phip,&ip,&jp);

			/* distance between cells (i,j) and (ip,jp) = 6 (time spent by TM1)
			 * */
			//graph[i*nCellsI+j][ip*nCellsI+jp] = 6;
			graph[ip*nCellsI+jp][i*nCellsI+j] = 6;

			/* map applied to go from (i,j) to (ip,jp) = TM1 */
			//graphMaps[i*nCellsI+j][ip*nCellsI+jp] = 1;
			graphMaps[ip*nCellsI+jp][i*nCellsI+j] = 1;
		}
	}

	/* Add (directed) edges corresponding to TM2, and assign them a distance of
	 * 6 time units. */
	for(i=0; i<nCellsI; i++)
	{
		for(j=0; j<nCellsPhi; j++)
		{
			cell2pt(i,j,&I,&phi);

			/* Compute TM2 */
			TM(nfour, ntori, ddA_SM2, ddB_SM2, ddOmega_SM2, N, M, I, phi, &Ip, &phip);
			pt2cell(Ip,phip,&ip,&jp);

			/* distance between cells (i,j) and (ip,jp) = 6 (time spent by TM2)
			 * */
			//graph[i*nCellsI+j][ip*nCellsI+jp] = 6;
			graph[ip*nCellsI+jp][i*nCellsI+j] = 6;

			/* map applied to go from (i,j) to (ip,jp) = TM2 */
			//graphMaps[i*nCellsI+j][ip*nCellsI+jp] = 2;
			graphMaps[ip*nCellsI+jp][i*nCellsI+j] = 2;
		}
	}

	/* Finally, add (directed) edges corresponding to IM, and assign them a
	 * distance of 3 time units. Notice that IM applications take prececence
	 * over TM applications, in case there is both an IM edge and a TM edge
	 * between (i,j) and (ip,jp). */
	for(i=0; i<nCellsI; i++)
	{
		for(j=0; j<nCellsPhi; j++)
		{
			cell2pt(i,j,&I,&phi);

			/* Compute IM */
			IM(I, phi, &Ip, &phip);
			phip = (phip>M_PI ? phip-M_PI : phip);
			pt2cell(Ip,phip,&ip,&jp);

			/* distance between cells (i,j) and (ip,jp) = 3 (time spent by IM)
			 * */
			//graph[i*nCellsI+j][ip*nCellsI+jp] = 3;
			graph[ip*nCellsI+jp][i*nCellsI+j] = 3;

			/* map applied to go from (i,j) to (ip,jp) = IM */
			//graphMaps[i*nCellsI+j][ip*nCellsI+jp] = 0;
			graphMaps[ip*nCellsI+jp][i*nCellsI+j] = 0;
		}
	}
}

void printGraph(int graph[MAX_VERTICES][MAX_VERTICES], 
		int graphMaps[MAX_VERTICES][MAX_VERTICES]) 
{
	int u,v;

	printf("Graph:\n");
	for(u=0; u<nCells; u++)
	{
		printf("Vertex %d: \n", u);
		for(v=0; v<nCells; v++)
		{
			printf("%d ", graph[u][v]);
		}
		printf("\n\n");
	}

	printf("Graph Maps:\n");
	for(u=0; u<nCells; u++)
	{
		printf("Vertex %d: \n", u);
		for(v=0; v<nCells; v++)
		{
			printf("%d ", graphMaps[u][v]);
		}
		printf("\n\n");
	}
}

int
main (int argc, char *argv[])
{
    double I, phi;      /* (I, \phi) = Point in the domain of the TM */
    double It, phit;    /* Target point whose cell we want to reach */

	double ddA[nfour][ntori];	/* divided differences of Fourier coeffs A_n(I) */
	double ddB[nfour][ntori];	/* divided differences of Fourier coeffs B_n(I) */
	double ddOmega[ntori-1];      /* divided differences of omega(I) */

	double ddA_SM2[nfour][ntori];	/* divided differences of Fourier coeffs A_n(I) */
	double ddB_SM2[nfour][ntori];	/* divided differences of Fourier coeffs B_n(I) */
	double ddOmega_SM2[ntori-1];      /* divided differences of omega(I) */

    double Ip, phip;    /* (I', \phi') = Image of (I, phi) by the IM/TM */

	/* graph[i][j] = distance from vertex i to vertex j */
	int graph[MAX_VERTICES][MAX_VERTICES];

	/* graphMaps[i][j] = map needed to go from vertex i to vertex j 
	 * Possible maps are: IM = 0, TM1 = 1, TM2 = 2 */
	int graphMaps[MAX_VERTICES][MAX_VERTICES];

	int prev[MAX_VERTICES];

	int i,j;	/* (i,j) = source cell */
	int ip,jp;	/* (ip, jp) = target cell */

	/* Source and target vertices */
	int source, target;

	/* next vertex */
	int current, next;	

    /* auxiliary vars */
	double phi_old;
	int map;

	/* Intermediate iterates in a TM. Needed to construct heteroclinic */
    double Ip1, phip1;    /* (I'_1, \phi'_1) = Image of (I, phi) by the IM */
    double Ip2, phip2;    /* (I'_2, \phi'_2) = Image of (I, phi) by the SM */

    if(argc != 5)
    {
        fprintf(stderr, "Num of args incorrect. Usage: %s I phi \
				I_target phi_target\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    I = atof(argv[1]);	    /* scaled action level, e.g. I=2 */
    phi = atof(argv[2]);	/* \phi */

    It = atof(argv[3]);	    /* I_target */
    phit = atof(argv[4]);	/* \phi_target */

    /* Read FT series (divided differences) from file */
    read_FT(nfour,ntori,SM1,ddA,ddB);
    read_FT(nfour,ntori,SM2,ddA_SM2,ddB_SM2);

    /* Read Taylor series (divided differences) from file */
    read_T(ntori-1,ddOmega_FILE,ddOmega);
    read_T(ntori-1,ddOmega_FILE_SM2,ddOmega_SM2);

	/* Initialize adjacency matrix for the graph */
	initGraph(ddA,ddB,ddOmega,ddA_SM2,ddB_SM2,ddOmega_SM2,graph,graphMaps);

	//printGraph(graph,graphMaps);

	pt2cell(I,phi,&i,&j);
	source = i*nCellsI+j;
	//printf("Source cell: (%d,%d) -> Source vertex: %d\n",i,j,source);

	pt2cell(It,phit,&ip,&jp);
	target = ip*nCellsI+jp;
	//printf("Target cell: (%d,%d) -> Target vertex: %d\n",ip,jp,target);

	printf("%f %f\n", I, phi);
	current = source;
    //while(current != target)
    while(fabs(I-It)+fabs(phi-phit)>0.5)
    {
		// Perform Dijkstra's algorithm
		dijkstra(graph, target, current, nCells, prev);

		next = prev[current];
		if(next == -1)
		{
			printf("No path from current vertex to target! Exiting\n");
			exit(EXIT_FAILURE);
		}
		/* The next vertex in the shortest path is `next' */

		map = graphMaps[next][current];
		if(map == 0)
		{
			/* Compute the IM: (I, phi) -> (Ip, phip) */
			IM(I, phi, &Ip, &phip);
			I = Ip;
			phi_old = phi;
			phi = phip;

			/* If angle phi wrapped around \pi, print newline. 
			   This is a trick for correctly plotting line segments in
			   diffusion_SM2.plt.
			 */
			if(phi_old<M_PI/2 && phi>M_PI/2) printf("\n");
				
			printf("%f %f %s\n", I, phi, "IM");
		}
		else if(map == 1)
		{
			/* Compute also the intermediate iterates, corresponding to IM and
			 * SM. This is needed to construct heteroclinic orbit segment. */
			IM(I,phi,&Ip1,&phip1);
			SM(nfour, ntori, ddA, ddB, ddOmega, N, M, Ip1, phip1, &Ip2, &phip2);
			
			/* Compute TM1 */
			TM(nfour, ntori, ddA, ddB, ddOmega, N, M, I, phi, &Ip, &phip);
			I = Ip;
			phi = phip;
			printf("%f %f %s ", I, phi, "TM1");

			/* Print also the intermediate iterates, corresponding to IM and
			 * SM. This is needed to construct heteroclinic orbit segment. */
			printf("%f %f ", Ip1, phip1);
			printf("%f %f \n", Ip2, phip2);
		}
		else	/* TM2 */
		{
			/* Compute also the intermediate iterates, corresponding to IM and
			 * SM. This is needed to construct heteroclinic orbit segment. */
			IM(I,phi,&Ip1,&phip1);
			SM(nfour, ntori, ddA_SM2, ddB_SM2, ddOmega_SM2, N, M, Ip1, phip1,
					&Ip2, &phip2);

			/* Compute TM2 */
			TM(nfour, ntori, ddA_SM2, ddB_SM2, ddOmega_SM2, N, M, I, phi, &Ip,
					&phip);
			I = Ip;
			phi = phip;
			printf("%f %f %s ", I, phi, "TM2");

			/* Print also the intermediate iterates, corresponding to IM and
			 * SM. This is needed to construct heteroclinic orbit segment. */
			printf("%f %f ", Ip1, phip1);
			printf("%f %f \n", Ip2, phip2);
		}

		/* Update current vertex */
		pt2cell(I,phi,&i,&j);
		current = i*nCellsI+j;
    }
    return 0;
}
