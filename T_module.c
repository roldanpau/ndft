/** \file T_module.c
  * \brief Functions to compute Taylor series of \f$\omega(I)\f$ and write it to file.
  *
  * NOTES: 
  *		Values of \f$\omega(I=2,3,\dotsc,6)\f$ are read from file
  *		omega_all.res, which was generated by omega_all.sh
  *
  * CALLED BY: T.c, FT_error.c	
  *
  */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_spline.h>

/** Constrain angle \f$ x \in [-2\pi, 2\pi) \f$ to be in \f$ [0, 2\pi) \f$.
  * Then, further constrain angle to \f$ [0, \pi) \f$.
 *
 */
double constrainAngle(double x){
    x = fmod(x,2*M_PI);
    if (x < 0)
        x += 2*M_PI;

	/* Further constrain to [0,\pi) */
	if (x>= M_PI) 
		x -= M_PI;
    return x;
}

/**
 * \brief Read omega values from file.
 *
 * Read omega values from file fn, which were generated by omega_all.sh.
 *
 * @param[in]   ntori   Number of tori
 * @param[in]   fn      Filename to read from
 *
 * @param[out]  omega_all   Table containing for each torus I, its omega value
 * \f$ \omega(I) \f$.
 */
void read_omegas(size_t ntori, const char *fn, double omega_all[ntori]) 
{
	/* auxiliary variables */
	FILE *fp;
	double I;

    fp = fopen(fn, "r");
	for(int i=0; i<ntori; i++)
	{
		fscanf(fp,"%le %le", &I, &(omega_all[i]));
	}
    fclose(fp);
}

typedef struct
{
    double *d;
    double *coef;
    double *work;
}
polynomial_state_t;

/** 
 * \brief Compute Taylor series, i.e. divided differences of \f$\omega(I)\f$.
 *
 * @param[in]   ntori	Number of tori
 * @param[in]   omega_all	Table containing for each torus I, \f$\omega(I)\f$.
 *
 * @param[out]  dd  Taylor series (div. difs. of omega).
 * 
 */
void compute_T(size_t ntori, double omega_all[ntori], double dd[ntori]) 
{
	const int n=ntori;

    double x[n], y[n];

    /* input curve */
    for(int i=0; i<n; i++)
    {
        x[i] = i+1;			    /* I */
        y[i] = omega_all[i];	/* \omega(I) */
    }
  
    gsl_interp_accel *acc
      = gsl_interp_accel_alloc ();
    gsl_spline *spline
      = gsl_spline_alloc (gsl_interp_polynomial, n);

    gsl_spline_init (spline, x, y, n);

    /* Obtain coefficients of interpolating polynomial P(x) */
    const polynomial_state_t *state = (const polynomial_state_t *) (spline
            -> interp -> state);

    for(int i=0; i<n; i++)
        dd[i] = state->d[i];

    gsl_spline_free (spline);
    gsl_interp_accel_free (acc);
}

/** 
 * \brief Write Taylor series (divided differences) to file.
 *
 * @param[in]   ntori   Degree of the Taylor series = ntori-1.
 * @param[in]   dd      Taylor series (div. difs. of omega).
 * @param[in]   fn      Filename to write to.
 */
void write_T(size_t ntori, double dd[ntori], const char *fn)
{
    FILE *fp = fopen(fn, "w");
    for(int j=0; j<ntori; j++)
    {
        fprintf(fp, "%lf ", dd[j]);
    }
    fprintf(fp, "\n");
    fclose(fp);
}

/** 
 * \brief Read Taylor series (divided differences) from file.
 *
 * @param[in]   ntori   Degree of the Taylor series = ntori-1.
 * @param[in]   fn		Filename to read from.
 *
 * @param[out]  dd      Taylor series (div. difs. of omega).
 */
void read_T(size_t ntori, const char *fn, double dd[ntori])
{
    FILE *fp = fopen(fn, "r");

	int nIt;	// Number of read items
    for(int j=0; j<ntori; j++)
    {
        nIt = fscanf(fp, "%lf ", &(dd[j]));
    }
    nIt = fscanf(fp, "\n");
    fclose(fp);
}

/** 
 * \brief Evaluate omega at I using Taylor interpolation.
 *
 * @param[in]   ntori   Max degree of the Taylor series = ntori-1.
 * @param[in]   dd      Complete Taylor series (div. difs. of omega).
 * @param[in]   M       Degree of the Taylor series.
 * @param[in]   I       Action at which we want to evaluate.
 *
 * @param[out]  omega_p     On exit, it points to the value omega(I).
 */
void omega_eval(size_t ntori, double dd[ntori], size_t M, double I, double
        *omega_p) 
{
    const double I0=1;
    const double I1=2;
    const double I2=3;
    const double I3=4;
    const double I4=5;
    const double I5=6;

    double d0, d1, d2, d3, d4, d5, d6;
    d0 = dd[0];
    d1 = dd[1];
    d2 = dd[2];
    d3 = dd[3];
    d4 = dd[4];
    d5 = dd[5];
    d6 = dd[6];

    /* Interpolate omega at I */
    assert(M<=6);
    switch(M)
    {
        case 0:
            *omega_p = d0;
            break;
        case 1:
            *omega_p = d0 + d1*(I-I0);
            break;
        case 2: 
            *omega_p = d0 + d1*(I-I0) + d2*(I-I0)*(I-I1);
            break;
        case 3:
            *omega_p = d0 + d1*(I-I0) + d2*(I-I0)*(I-I1) +
                d3*(I-I0)*(I-I1)*(I-I2);
            break;
        case 4:
            *omega_p = d0 + d1*(I-I0) + d2*(I-I0)*(I-I1) +
                d3*(I-I0)*(I-I1)*(I-I2) + 
                d4*(I-I0)*(I-I1)*(I-I2)*(I-I3);
            break;
	    case 5:
			*(omega_p) = d0 + d1*(I-I0) + d2*(I-I0)*(I-I1) +
				d3*(I-I0)*(I-I1)*(I-I2) +
				d4*(I-I0)*(I-I1)*(I-I2)*(I-I3) +
				d5*(I-I0)*(I-I1)*(I-I2)*(I-I3)*(I-I4);
			break;
		case 6:
			*(omega_p) = d0 + d1*(I-I0) + d2*(I-I0)*(I-I1) +
				d3*(I-I0)*(I-I1)*(I-I2) +
				d4*(I-I0)*(I-I1)*(I-I2)*(I-I3) +
				d5*(I-I0)*(I-I1)*(I-I2)*(I-I3)*(I-I4) +
				d6*(I-I0)*(I-I1)*(I-I2)*(I-I3)*(I-I4)*(I-I5);
			break;
        default:
            break;
    }
}

